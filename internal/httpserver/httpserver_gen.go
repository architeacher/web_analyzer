// Package httpserver provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package httpserver

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	PasteoAuthScopes = "PasteoAuth.Scopes"
)

// Defines values for AnalysisDataFormsLoginFormDetailsMethod.
const (
	AnalysisDataFormsLoginFormDetailsMethodPOST AnalysisDataFormsLoginFormDetailsMethod = "POST"
)

// Defines values for AnalysisErrorStatus.
const (
	AnalysisErrorStatusFailed AnalysisErrorStatus = "failed"
)

// Defines values for AnalysisInProgressStatus.
const (
	InProgress AnalysisInProgressStatus = "in_progress"
)

// Defines values for AnalysisResponseStatus.
const (
	AnalysisResponseStatusCompleted  AnalysisResponseStatus = "completed"
	AnalysisResponseStatusFailed     AnalysisResponseStatus = "failed"
	AnalysisResponseStatusInProgress AnalysisResponseStatus = "in_progress"
	AnalysisResponseStatusRequested  AnalysisResponseStatus = "requested"
)

// Defines values for AnalysisResultResultsFormsLoginFormDetailsMethod.
const (
	AnalysisResultResultsFormsLoginFormDetailsMethodPOST AnalysisResultResultsFormsLoginFormDetailsMethod = "POST"
)

// Defines values for AnalysisResultStatus.
const (
	Completed AnalysisResultStatus = "completed"
)

// Defines values for FormAnalysisLoginFormDetailsMethod.
const (
	FormAnalysisLoginFormDetailsMethodPOST FormAnalysisLoginFormDetailsMethod = "POST"
)

// Defines values for HealthResponseDependenciesCache.
const (
	HealthResponseDependenciesCacheHealthy   HealthResponseDependenciesCache = "healthy"
	HealthResponseDependenciesCacheUnhealthy HealthResponseDependenciesCache = "unhealthy"
)

// Defines values for HealthResponseDependenciesDatabase.
const (
	HealthResponseDependenciesDatabaseHealthy   HealthResponseDependenciesDatabase = "healthy"
	HealthResponseDependenciesDatabaseUnhealthy HealthResponseDependenciesDatabase = "unhealthy"
)

// Defines values for HealthResponseDependenciesExternalServices.
const (
	HealthResponseDependenciesExternalServicesHealthy   HealthResponseDependenciesExternalServices = "healthy"
	HealthResponseDependenciesExternalServicesUnhealthy HealthResponseDependenciesExternalServices = "unhealthy"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusHealthy   HealthResponseStatus = "healthy"
	HealthResponseStatusUnhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for LoginFormMethod.
const (
	LoginFormMethodPOST LoginFormMethod = "POST"
)

// Defines values for ApiVersionHeader.
const (
	ApiVersionHeaderV1 ApiVersionHeader = "v1"
)

// Defines values for GetAnalysisParamsAPIVersion.
const (
	GetAnalysisParamsAPIVersionV1 GetAnalysisParamsAPIVersion = "v1"
)

// Defines values for GetAnalysisEventsParamsAPIVersion.
const (
	GetAnalysisEventsParamsAPIVersionV1 GetAnalysisEventsParamsAPIVersion = "v1"
)

// Defines values for AnalyzeURLParamsAPIVersion.
const (
	AnalyzeURLParamsAPIVersionV1 AnalyzeURLParamsAPIVersion = "v1"
)

// AnalysisData defines model for AnalysisData.
type AnalysisData struct {
	Forms *struct {
		LoginFormDetails *[]struct {
			// Action Form action URL
			Action *string `json:"action,omitempty"`

			// Fields Form field names
			Fields *[]string `json:"fields,omitempty"`

			// Method Form submission method (login forms use POST)
			Method *AnalysisDataFormsLoginFormDetailsMethod `json:"method,omitempty"`
		} `json:"login_form_details,omitempty"`

		// LoginFormsDetected Number of login forms detected
		LoginFormsDetected *int `json:"login_forms_detected,omitempty"`

		// TotalCount Total number of forms found
		TotalCount *int `json:"total_count,omitempty"`
	} `json:"forms,omitempty"`
	HeadingCounts *struct {
		H1 *int `json:"h1,omitempty"`
		H2 *int `json:"h2,omitempty"`
		H3 *int `json:"h3,omitempty"`
		H4 *int `json:"h4,omitempty"`
		H5 *int `json:"h5,omitempty"`
		H6 *int `json:"h6,omitempty"`
	} `json:"heading_counts,omitempty"`

	// HtmlVersion Detected HTML version
	HtmlVersion *string `json:"html_version,omitempty"`
	Links       *struct {
		// ExternalCount Number of external links
		ExternalCount     *int `json:"external_count,omitempty"`
		InaccessibleLinks *[]struct {
			// Error Error description
			Error *string `json:"error,omitempty"`

			// StatusCode HTTP status code received
			StatusCode *int    `json:"status_code,omitempty"`
			Url        *string `json:"url,omitempty"`
		} `json:"inaccessible_links,omitempty"`

		// InternalCount Number of internal links
		InternalCount *int `json:"internal_count,omitempty"`

		// TotalCount Total number of links
		TotalCount *int `json:"total_count,omitempty"`
	} `json:"links,omitempty"`

	// Title Page title
	Title *string `json:"title,omitempty"`
}

// AnalysisDataFormsLoginFormDetailsMethod Form submission method (login forms use POST)
type AnalysisDataFormsLoginFormDetailsMethod string

// AnalysisError defines model for AnalysisError.
type AnalysisError struct {
	AnalysisId *openapi_types.UUID `json:"analysis_id,omitempty"`

	// Details Additional error details
	Details *string `json:"details,omitempty"`

	// Error Error type
	Error *string `json:"error,omitempty"`

	// ErrorMessage Human-readable error message
	ErrorMessage *string `json:"error_message,omitempty"`

	// HttpStatusCode HTTP status code from the target URL (if applicable)
	HttpStatusCode *int                 `json:"http_status_code,omitempty"`
	Status         *AnalysisErrorStatus `json:"status,omitempty"`
}

// AnalysisErrorStatus defines model for AnalysisError.Status.
type AnalysisErrorStatus string

// AnalysisInProgress defines model for AnalysisInProgress.
type AnalysisInProgress struct {
	AnalysisId *openapi_types.UUID `json:"analysis_id,omitempty"`

	// CurrentStep Current analysis step
	CurrentStep *string `json:"current_step,omitempty"`

	// EstimatedCompletionTime Estimated time to completion
	EstimatedCompletionTime *string `json:"estimated_completion_time,omitempty"`

	// Progress Progress percentage
	Progress *int                      `json:"progress,omitempty"`
	Status   *AnalysisInProgressStatus `json:"status,omitempty"`
}

// AnalysisInProgressStatus defines model for AnalysisInProgress.Status.
type AnalysisInProgressStatus string

// AnalysisResponse defines model for AnalysisResponse.
type AnalysisResponse struct {
	// AnalysisId Unique identifier for the analysis
	AnalysisId *openapi_types.UUID `json:"analysis_id,omitempty"`

	// CreatedAt When the analysis was created
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// EstimatedCompletionTime Estimated time to completion
	EstimatedCompletionTime *string `json:"estimated_completion_time,omitempty"`

	// Status Current status of the analysis
	Status *AnalysisResponseStatus `json:"status,omitempty"`

	// Url The URL being analyzed
	Url *string `json:"url,omitempty"`
}

// AnalysisResponseStatus Current status of the analysis
type AnalysisResponseStatus string

// AnalysisResult defines model for AnalysisResult.
type AnalysisResult struct {
	AnalysisId  *openapi_types.UUID `json:"analysis_id,omitempty"`
	CompletedAt *time.Time          `json:"completed_at,omitempty"`
	CreatedAt   *time.Time          `json:"created_at,omitempty"`

	// Duration Analysis duration
	Duration *string `json:"duration,omitempty"`
	Results  *struct {
		Forms *struct {
			LoginFormDetails *[]struct {
				// Action Form action URL
				Action *string `json:"action,omitempty"`

				// Fields Form field names
				Fields *[]string `json:"fields,omitempty"`

				// Method Form submission method (login forms use POST)
				Method *AnalysisResultResultsFormsLoginFormDetailsMethod `json:"method,omitempty"`
			} `json:"login_form_details,omitempty"`

			// LoginFormsDetected Number of login forms detected
			LoginFormsDetected *int `json:"login_forms_detected,omitempty"`

			// TotalCount Total number of forms found
			TotalCount *int `json:"total_count,omitempty"`
		} `json:"forms,omitempty"`
		HeadingCounts *struct {
			H1 *int `json:"h1,omitempty"`
			H2 *int `json:"h2,omitempty"`
			H3 *int `json:"h3,omitempty"`
			H4 *int `json:"h4,omitempty"`
			H5 *int `json:"h5,omitempty"`
			H6 *int `json:"h6,omitempty"`
		} `json:"heading_counts,omitempty"`

		// HtmlVersion Detected HTML version
		HtmlVersion *string `json:"html_version,omitempty"`
		Links       *struct {
			// ExternalCount Number of external links
			ExternalCount     *int `json:"external_count,omitempty"`
			InaccessibleLinks *[]struct {
				// Error Error description
				Error *string `json:"error,omitempty"`

				// StatusCode HTTP status code received
				StatusCode *int    `json:"status_code,omitempty"`
				Url        *string `json:"url,omitempty"`
			} `json:"inaccessible_links,omitempty"`

			// InternalCount Number of internal links
			InternalCount *int `json:"internal_count,omitempty"`

			// TotalCount Total number of links
			TotalCount *int `json:"total_count,omitempty"`
		} `json:"links,omitempty"`

		// Title Page title
		Title *string `json:"title,omitempty"`
	} `json:"results,omitempty"`
	Status *AnalysisResultStatus `json:"status,omitempty"`
	Url    *string               `json:"url,omitempty"`
}

// AnalysisResultResultsFormsLoginFormDetailsMethod Form submission method (login forms use POST)
type AnalysisResultResultsFormsLoginFormDetailsMethod string

// AnalysisResultStatus defines model for AnalysisResult.Status.
type AnalysisResultStatus string

// AnalyzeRequest defines model for AnalyzeRequest.
type AnalyzeRequest struct {
	Options *struct {
		// CheckLinks Whether to check link accessibility
		CheckLinks *bool `json:"check_links,omitempty"`

		// DetectForms Whether to detect login forms
		DetectForms *bool `json:"detect_forms,omitempty"`

		// IncludeHeadings Whether to include heading analysis
		IncludeHeadings *bool `json:"include_headings,omitempty"`

		// Timeout Request timeout in seconds
		Timeout *int `json:"timeout,omitempty"`
	} `json:"options,omitempty"`

	// Url The URL to analyze
	Url string `json:"url"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Additional error details
	Details *string `json:"details,omitempty"`

	// Error Error code
	Error *string `json:"error,omitempty"`

	// Message Human-readable error message
	Message *string `json:"message,omitempty"`

	// RetryAfter Seconds to wait before retrying (for rate limit errors)
	RetryAfter *int `json:"retry_after,omitempty"`

	// StatusCode HTTP status code
	StatusCode *int       `json:"status_code,omitempty"`
	Timestamp  *time.Time `json:"timestamp,omitempty"`
}

// FormAnalysis defines model for FormAnalysis.
type FormAnalysis struct {
	LoginFormDetails *[]struct {
		// Action Form action URL
		Action *string `json:"action,omitempty"`

		// Fields Form field names
		Fields *[]string `json:"fields,omitempty"`

		// Method Form submission method (login forms use POST)
		Method *FormAnalysisLoginFormDetailsMethod `json:"method,omitempty"`
	} `json:"login_form_details,omitempty"`

	// LoginFormsDetected Number of login forms detected
	LoginFormsDetected *int `json:"login_forms_detected,omitempty"`

	// TotalCount Total number of forms found
	TotalCount *int `json:"total_count,omitempty"`
}

// FormAnalysisLoginFormDetailsMethod Form submission method
type FormAnalysisLoginFormDetailsMethod string

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	Dependencies *struct {
		Cache            *HealthResponseDependenciesCache            `json:"cache,omitempty"`
		Database         *HealthResponseDependenciesDatabase         `json:"database,omitempty"`
		ExternalServices *HealthResponseDependenciesExternalServices `json:"external_services,omitempty"`
	} `json:"dependencies,omitempty"`
	Status    *HealthResponseStatus `json:"status,omitempty"`
	Timestamp *time.Time            `json:"timestamp,omitempty"`
	Version   *string               `json:"version,omitempty"`
}

// HealthResponseDependenciesCache defines model for HealthResponse.Dependencies.Cache.
type HealthResponseDependenciesCache string

// HealthResponseDependenciesDatabase defines model for HealthResponse.Dependencies.Database.
type HealthResponseDependenciesDatabase string

// HealthResponseDependenciesExternalServices defines model for HealthResponse.Dependencies.ExternalServices.
type HealthResponseDependenciesExternalServices string

// HealthResponseStatus defines model for HealthResponse.Status.
type HealthResponseStatus string

// InaccessibleLink defines model for InaccessibleLink.
type InaccessibleLink struct {
	// Error Error description
	Error *string `json:"error,omitempty"`

	// StatusCode HTTP status code received
	StatusCode *int    `json:"status_code,omitempty"`
	Url        *string `json:"url,omitempty"`
}

// LinkAnalysis defines model for LinkAnalysis.
type LinkAnalysis struct {
	// ExternalCount Number of external links
	ExternalCount     *int `json:"external_count,omitempty"`
	InaccessibleLinks *[]struct {
		// Error Error description
		Error *string `json:"error,omitempty"`

		// StatusCode HTTP status code received
		StatusCode *int    `json:"status_code,omitempty"`
		Url        *string `json:"url,omitempty"`
	} `json:"inaccessible_links,omitempty"`

	// InternalCount Number of internal links
	InternalCount *int `json:"internal_count,omitempty"`

	// TotalCount Total number of links
	TotalCount *int `json:"total_count,omitempty"`
}

// LoginForm defines model for LoginForm.
type LoginForm struct {
	// Action Form action URL
	Action *string `json:"action,omitempty"`

	// Fields Form field names
	Fields *[]string `json:"fields,omitempty"`

	// Method Form submission method
	Method *LoginFormMethod `json:"method,omitempty"`
}

// LoginFormMethod Form submission method
type LoginFormMethod string

// Pagination defines model for Pagination.
type Pagination struct {
	HasNext     *bool `json:"has_next,omitempty"`
	HasPrevious *bool `json:"has_previous,omitempty"`
	Limit       *int  `json:"limit,omitempty"`
	Page        *int  `json:"page,omitempty"`
	TotalCount  *int  `json:"total_count,omitempty"`
	TotalPages  *int  `json:"total_pages,omitempty"`
}

// ApiVersionHeader defines model for ApiVersionHeader.
type ApiVersionHeader string

// BadRequest defines model for bad_request.
type BadRequest struct {
	// Details Additional error details
	Details *string `json:"details,omitempty"`

	// Error Error code
	Error *string `json:"error,omitempty"`

	// Message Human-readable error message
	Message *string `json:"message,omitempty"`

	// RetryAfter Seconds to wait before retrying (for rate limit errors)
	RetryAfter *int `json:"retry_after,omitempty"`

	// StatusCode HTTP status code
	StatusCode *int       `json:"status_code,omitempty"`
	Timestamp  *time.Time `json:"timestamp,omitempty"`
}

// NotFound defines model for not_found.
type NotFound struct {
	// Details Additional error details
	Details *string `json:"details,omitempty"`

	// Error Error code
	Error *string `json:"error,omitempty"`

	// Message Human-readable error message
	Message *string `json:"message,omitempty"`

	// RetryAfter Seconds to wait before retrying (for rate limit errors)
	RetryAfter *int `json:"retry_after,omitempty"`

	// StatusCode HTTP status code
	StatusCode *int       `json:"status_code,omitempty"`
	Timestamp  *time.Time `json:"timestamp,omitempty"`
}

// RateLimit defines model for rate_limit.
type RateLimit struct {
	// Details Additional error details
	Details *string `json:"details,omitempty"`

	// Error Error code
	Error *string `json:"error,omitempty"`

	// Message Human-readable error message
	Message *string `json:"message,omitempty"`

	// RetryAfter Seconds to wait before retrying (for rate limit errors)
	RetryAfter *int `json:"retry_after,omitempty"`

	// StatusCode HTTP status code
	StatusCode *int       `json:"status_code,omitempty"`
	Timestamp  *time.Time `json:"timestamp,omitempty"`
}

// ServerError defines model for server_error.
type ServerError struct {
	// Details Additional error details
	Details *string `json:"details,omitempty"`

	// Error Error code
	Error *string `json:"error,omitempty"`

	// Message Human-readable error message
	Message *string `json:"message,omitempty"`

	// RetryAfter Seconds to wait before retrying (for rate limit errors)
	RetryAfter *int `json:"retry_after,omitempty"`

	// StatusCode HTTP status code
	StatusCode *int       `json:"status_code,omitempty"`
	Timestamp  *time.Time `json:"timestamp,omitempty"`
}

// Unauthorized defines model for unauthorized.
type Unauthorized struct {
	// Details Additional error details
	Details *string `json:"details,omitempty"`

	// Error Error code
	Error *string `json:"error,omitempty"`

	// Message Human-readable error message
	Message *string `json:"message,omitempty"`

	// RetryAfter Seconds to wait before retrying (for rate limit errors)
	RetryAfter *int `json:"retry_after,omitempty"`

	// StatusCode HTTP status code
	StatusCode *int       `json:"status_code,omitempty"`
	Timestamp  *time.Time `json:"timestamp,omitempty"`
}

// GetAnalysisParams defines parameters for GetAnalysis.
type GetAnalysisParams struct {
	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *GetAnalysisParamsAPIVersion `json:"API-Version,omitempty"`
}

// GetAnalysisParamsAPIVersion defines parameters for GetAnalysis.
type GetAnalysisParamsAPIVersion string

// GetAnalysisEventsParams defines parameters for GetAnalysisEvents.
type GetAnalysisEventsParams struct {
	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *GetAnalysisEventsParamsAPIVersion `json:"API-Version,omitempty"`
}

// GetAnalysisEventsParamsAPIVersion defines parameters for GetAnalysisEvents.
type GetAnalysisEventsParamsAPIVersion string

// AnalyzeURLJSONBody defines parameters for AnalyzeURL.
type AnalyzeURLJSONBody struct {
	Options *struct {
		// CheckLinks Whether to check link accessibility
		CheckLinks *bool `json:"check_links,omitempty"`

		// DetectForms Whether to detect login forms
		DetectForms *bool `json:"detect_forms,omitempty"`

		// IncludeHeadings Whether to include heading analysis
		IncludeHeadings *bool `json:"include_headings,omitempty"`

		// Timeout Request timeout in seconds
		Timeout *int `json:"timeout,omitempty"`
	} `json:"options,omitempty"`

	// Url The URL to analyze
	Url string `json:"url"`
}

// AnalyzeURLParams defines parameters for AnalyzeURL.
type AnalyzeURLParams struct {
	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *AnalyzeURLParamsAPIVersion `json:"API-Version,omitempty"`
}

// AnalyzeURLParamsAPIVersion defines parameters for AnalyzeURL.
type AnalyzeURLParamsAPIVersion string

// AnalyzeURLJSONRequestBody defines body for AnalyzeURL for application/json ContentType.
type AnalyzeURLJSONRequestBody AnalyzeURLJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get analysis result
	// (GET /v1/analysis/{analysisId})
	GetAnalysis(w http.ResponseWriter, r *http.Request, analysisId openapi_types.UUID, params GetAnalysisParams)
	// Get real-time analysis progress
	// (GET /v1/analysis/{analysisId}/events)
	GetAnalysisEvents(w http.ResponseWriter, r *http.Request, analysisId openapi_types.UUID, params GetAnalysisEventsParams)
	// Analyze a web page
	// (POST /v1/analyze)
	AnalyzeURL(w http.ResponseWriter, r *http.Request, params AnalyzeURLParams)
	// Health check
	// (GET /v1/health)
	HealthCheck(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Get analysis result
// (GET /v1/analysis/{analysisId})
func (_ Unimplemented) GetAnalysis(w http.ResponseWriter, r *http.Request, analysisId openapi_types.UUID, params GetAnalysisParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get real-time analysis progress
// (GET /v1/analysis/{analysisId}/events)
func (_ Unimplemented) GetAnalysisEvents(w http.ResponseWriter, r *http.Request, analysisId openapi_types.UUID, params GetAnalysisEventsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Analyze a web page
// (POST /v1/analyze)
func (_ Unimplemented) AnalyzeURL(w http.ResponseWriter, r *http.Request, params AnalyzeURLParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Health check
// (GET /v1/health)
func (_ Unimplemented) HealthCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetAnalysis operation middleware
func (siw *ServerInterfaceWrapper) GetAnalysis(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "analysisId" -------------
	var analysisId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "analysisId", chi.URLParam(r, "analysisId"), &analysisId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "analysisId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasteoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnalysisParams

	headers := r.Header

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion GetAnalysisParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnalysis(w, r, analysisId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAnalysisEvents operation middleware
func (siw *ServerInterfaceWrapper) GetAnalysisEvents(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "analysisId" -------------
	var analysisId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "analysisId", chi.URLParam(r, "analysisId"), &analysisId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "analysisId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasteoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnalysisEventsParams

	headers := r.Header

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion GetAnalysisEventsParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnalysisEvents(w, r, analysisId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AnalyzeURL operation middleware
func (siw *ServerInterfaceWrapper) AnalyzeURL(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasteoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AnalyzeURLParams

	headers := r.Header

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion AnalyzeURLParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AnalyzeURL(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/analysis/{analysisId}", wrapper.GetAnalysis)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/analysis/{analysisId}/events", wrapper.GetAnalysisEvents)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/analyze", wrapper.AnalyzeURL)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/health", wrapper.HealthCheck)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
